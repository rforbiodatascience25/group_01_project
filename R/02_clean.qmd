---
title: "02_clean"
format: html
---

# Cleaning data

Clean \_raw/ data to data/

Converts each of the following to a tibble dataframe in the tidy format

-   the expression GEODataTable from GDS in \_raw/

-   the metadata from GSE

    -   phenoData\$data - metadata concerning samples (patients)

    -   featureData\$data - metadata concerning genes

**Setup/Initialization**

```{r}
#| message: false
#| warning: false

data_dir <- "../data/"
raw_dir <- "../data/_raw/"

```

## GEODataTable from \_raw/gds3268.rds

#### Loading in the data

Expression data of patients with different genes. (patient) Samples are stored as columns and gene names as rows, which we would like to flip, to align with tidy standards. But first we load the data from \_raw/

```{r}
#Applying the Table function from GEOquery to extract the dataframe.
exprs_geodf <- Table(read_rds(file.path(raw_dir,"gds3268.rds")))
#exprs_geodf <- Table(read_rds("../_raw/gds3268.rds"))
exprs_geodf <- as_tibble(exprs_geodf)
exprs_geodf
```

Now we can treat it as a normal dataframe to try to clean it to a tidy dataframe.

#### Removing empty rows

All 204 columns are (patient) Samples, and of type \<dbl\> with NA values. With this data we would like to keep the random NA values that appear throughout the dataset as they clearly represent no data. Substituting it with zeros would indicate that there is no expression of that gene in that sample, which is not necessarily the case (most likely not). Although, if an entire row is made of zeros, we would like to exclude that gene.

```{r}
fully_na <- exprs_geodf |>
  filter(if_all(starts_with("GSM"), is.na)) |> 
  select("ID_REF") 

count(fully_na)
```

There are 3299 identifiers with completely empty rows in the expression dataset, given in the list "fully_na". We cannot use the gene column name: "IDENTIFIER", as it contains duplicates. Lets exclude fully_na indexes from the dataset:

```{r}
exprs_df <- exprs_geodf |> 
  anti_join(fully_na, by = "ID_REF")

exprs_df
```

With our little sanity check below, we can confirm that 3299 rows has been filtered from the data, matching the number of empty rows (fully_na)

```{r}
dim(exprs_geodf)[[1]] - dim(exprs_df)[[1]] - dim(fully_na)[[1]]
```

We could choose to reset ID_REF values and keep them as the index of the frame (essentially removing them), but that would obscure us from combining the expression dataframe with any potential meta data later on. We therefore instead denote the ID_REF column as lookup keys; since they're unique.

#### Transposing the dataframe

As according to tidy principles, we need variables (gene names) as columns and observations (samples) as rows, which is currently flipped. We therefore need to transpose the dataframe.

We can use pivot_longer to concatenate columns and values except *ID_REF*, and then pivot_wider to unpack the values along with *ID_REF*, leaving sample names as row names. Although, currently we have both *ID_REF* and *IDENTIFIER* functioning as column headers. We choose to exclude the IDENTIFIER column from the table, and combine it with future metadata tables. As long as the ID_REF is present, we can lookup any meta data there might be for either variables and observations.

```{r}
identifier_exprs <- exprs_df |>  # for later use
  select(ID_REF, IDENTIFIER)

exprs_df <- exprs_df |> 
  select(-IDENTIFIER) |> 
  
  #Packing column names to one (except ID_REF)
  pivot_longer(
    cols = -ID_REF,          
    names_to = "geo_accession", 
    values_to = "Value"  
  ) |>
  
  #Unpacking ID_REF as columns
  pivot_wider(
    names_from = ID_REF,
    values_from = Value
  )

exprs_df
```

Now we see the data transposed with 202 rows and 40,992 columns, as opposed to the opposite before.

## phenoData\$data from \_raw/gse11223.rds

Metadata concerning samples (patients)

```{r}
gse11223 <- read_rds(file = file.path(raw_dir,"gse11223.rds")) 

phenodata <- pData(phenoData(gse11223[1]))

phenodata |>
  summarise(across(everything(), ~ n_distinct(.x, na.rm = TRUE))) |>
  pivot_longer(
    everything(),
    names_to = "col",
    values_to = "n_levels"
  ) |>
  filter(n_levels <= 1)
```

Once we spotted the "one type columns" we drop them. Then we check the remaining ones.

```{r}
phenodata <- phenodata |>
  select(where(~ n_distinct(.x, na.rm = TRUE) > 1))

names(phenodata)
phenodata
```

```{r}
library(tidyverse)

# Select only the characteristics_* columns
char_cols <- phenodata |> 
  select(starts_with("characteristics_ch1"))

# Extract a unique prefix (text before ':') for each column
prefixes <- char_cols |> 
  map_chr(~ {
    vals <- na.omit(.x)
    pref <- str_extract(vals, "^[^:]+") |> unique()
    # keep only columns where ALL rows share the same prefix
    if (length(pref) == 1) pref else NA_character_
  })

# Keep only columns with a valid single prefix
valid_cols <- names(prefixes)[!is.na(prefixes)]

# Build clean column names (lowercase + underscores)
new_names <- prefixes[valid_cols] |> 
  tolower() |> 
  str_replace_all("\\s+", "_")

# Remove the prefix from cell contents, keep only the value
phenodata[valid_cols] <- map2_df(
  phenodata[valid_cols],
  prefixes[valid_cols],
  ~ str_remove(.x, paste0("^", .y, "\\s*:\\s*")) |> str_trim()
)

# Rename the columns to their extracted prefix
names(phenodata)[match(valid_cols, names(phenodata))] <- new_names

```

The phenodata has been extracted from the gse11223 and now we will pick and choose the data that is, perhaps removing those variables that are of no importance for us, such as status, submission_date, type, channel_count, organism_ch1 (as they are all homo sapiens) and characteristics_ch1

maybe more.

## Merging phenodata

Do a left_join() with phenodata and exprs_df on geo_accession

```{r}

finaldata <- right_join(phenodata, exprs_df, by = "geo_accession")
```

Stretching the data set so that genes

```{r}
finaldata <-  finaldata |> 
  pivot_longer(cols = 152:last_col(),
               names_to = "gene_id" ,
               values_to = "gene_expr" )

```

## featureData\$data from \_raw/gse11223.rds

Metadata concerning genes

```{r}
featuredata <- pData(featureData(gse11223))
```

## Exporting to data/

```{r}
write_csv(finaldata, file = "../data/finaldata.csv")
write_csv(featuredata, file = "../data/featuredata.csv")
```

## Cleaning environment

```{r}
rm(list = setdiff(ls(), c("finaldata", "featuredata")))
```
